parameter (or :parameter (pair :initiate %Initiate (nat %iRefTime) (pair (bytes %iHSec) (pair (address %iPartie) (bool %iMaster)))) (or (pair :redeem %Redeem (bytes %rdHSec) (bytes %rdSec)) (bytes %Refund)));
storage (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit);
code { DUP ;
       DIP { CDR @stor_slash_1 } ;
       CAR @param_slash_2 ;
       LAMBDA @transfer address (pair (lambda (pair mutez address) (list operation)) address) { RENAME @address_slash_22 ; LAMBDA (pair mutez address) (list operation) { RENAME @closure_env_slash_23 ; DUP ; CDR @address_slash_22 ; CONTRACT unit ; IF_NONE { NIL operation }
               { NIL operation ;
                 SWAP ;
                 { DIP { { DIP { DUP } ; SWAP } } ; SWAP } ;
                 CAR @amount_slash_24 ;
                 UNIT ;
                 TRANSFER_TOKENS ;
                 CONS } ; DIP { DROP } } ; PAIR } ;
       { DIP { DUP @param } ; SWAP } ;
       IF_LEFT { RENAME @init_slash_65 ;
                 LAMBDA @isInitiatable bytes (pair (lambda (pair bool bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bool)) bool) (pair bytes bool))) bytes) { RENAME @hSec_slash_15 ; LAMBDA (pair bool bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bool)) bool) (pair bytes bool)) { RENAME @closure_env_slash_16 ; DUP ; CAR @master_slash_17 ; SWAP ; CDR @hSec_slash_15 ; PAIR ; LAMBDA (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bool)) bool { RENAME @closure_env_slash_18 ; DUP ; CAR @swaps_slash_19 ; { DIP { DUP } ; SWAP } ; { CDR ; CAR @hSec_slash_15 } ; GET ; IF_NONE { DUP ;
                           { CDR ; CDR @master_slash_17 } ;
                           NOT ;
                           IF { PUSH string "have to be master" ;
                                FAILWITH }
                              { PUSH bool True } }
                         { DUP @swap ;
                           { CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CAR %empt } ;
                           IF { PUSH string "hash is spent" ;
                                FAILWITH }
                              { DUP @swap ;
                                { CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CDR %state } ;
                                IF_LEFT { DROP ;
                                          PUSH bool False }
                                        { DROP ;
                                          { DIP { DUP } ; SWAP } ;
                                          { CDR ; CDR @master_slash_17 } ;
                                          IF { PUSH string "hash is initiated" ;
                                               FAILWITH }
                                             { DUP @swap ;
                                               { CDR ; CAR %refTime } ;
                                               INT ;
                                               { DIP { DUP @swap } ; SWAP } ;
                                               CAR %initTs ;
                                               ADD ;
                                               NOW ;
                                               COMPARE ;
                                               GE ;
                                               IF { PUSH string "refundTime has come" ;
                                                    FAILWITH }
                                                  { PUSH bool True } } } } ;
                           DIP { DROP } } ; DIP { DROP } } ; PAIR } ; PAIR } ;
                 LAMBDA (pair (pair :initiate (nat %iRefTime) (pair (bytes %iHSec) (pair (address %iPartie) (bool %iMaster)))) (lambda bytes (pair (lambda (pair bool bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bool)) bool) (pair bytes bool))) bytes))) (pair (lambda (pair (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit) (pair (pair :initiate (nat %iRefTime) (pair (bytes %iHSec) (pair (address %iPartie) (bool %iMaster)))) (lambda bytes (pair (lambda (pair bool bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bool)) bool) (pair bytes bool))) bytes)))) (pair (list operation) (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit))) (pair (pair :initiate (nat %iRefTime) (pair (bytes %iHSec) (pair (address %iPartie) (bool %iMaster)))) (lambda bytes (pair (lambda (pair bool bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bool)) bool) (pair bytes bool))) bytes)))) { RENAME @closure_env_slash_27 ; DUP ; CDR @isInitiatable_slash_21 ; SWAP ; CAR @init_slash_28 ; PAIR ; LAMBDA (pair (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit) (pair (pair :initiate (nat %iRefTime) (pair (bytes %iHSec) (pair (address %iPartie) (bool %iMaster)))) (lambda bytes (pair (lambda (pair bool bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bool)) bool) (pair bytes bool))) bytes)))) (pair (list operation) (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit)) { RENAME @closure_env_slash_29 ; DUP ; { CDR ; CDR @isInitiatable_slash_21 } ; { DIP { DUP } ; SWAP } ; { CDR ; CAR @init_slash_28 } ; { CDR ; CAR %iHSec } ; EXEC ; { DIP { DUP } ; SWAP } ; { CDR ; CAR @init_slash_28 } ; { CDR ; CDR ; CDR %iMaster } ; DIP { DUP ; CAR ; SWAP ; CDR } ; PAIR ; EXEC ; { DIP { DUP } ; SWAP } ; CAR @stor_slash_30 ; CAR %swaps ; DIP { DUP ; CAR ; SWAP ; CDR } ; PAIR ; EXEC ; NOT ; IF { UNIT ;
                      FAILWITH }
                    { UNIT } ; DROP ; DUP ; CAR @stor_slash_30 ; CAR %swaps ; { DIP { DUP } ; SWAP } ; { CDR ; CAR @init_slash_28 } ; { CDR ; CAR %iHSec } ; GET ; IF_NONE { UNIT @nth ;
                           { DIP { DUP } ; SWAP } ;
                           CAR @stor_slash_30 ;
                           CAR %swaps ;
                           PUSH (or :state (unit %Empty) (unit %Initiator)) (Right Unit) ;
                           PUSH bool False ;
                           PAIR %empt %state ;
                           AMOUNT ;
                           PAIR %value ;
                           { DIP { { DIP { { DIP { DUP } ; SWAP } } ; SWAP } } ; SWAP } ;
                           { CDR ; CAR @init_slash_28 } ;
                           { CDR ; CDR ; CAR %iPartie } ;
                           PAIR %partie ;
                           SENDER ;
                           PAIR %initor ;
                           NONE bytes ;
                           PAIR %sec ;
                           { DIP { { DIP { { DIP { DUP } ; SWAP } } ; SWAP } } ; SWAP } ;
                           { CDR ; CAR @init_slash_28 } ;
                           { CDR ; CAR %iHSec } ;
                           PAIR %hSec ;
                           { DIP { { DIP { { DIP { DUP } ; SWAP } } ; SWAP } } ; SWAP } ;
                           { CDR ; CAR @init_slash_28 } ;
                           CAR %iRefTime ;
                           PAIR %refTime ;
                           NOW ;
                           PAIR @nSwap %initTs ;
                           { DIP { { DIP { { DIP { DUP } ; SWAP } } ; SWAP } } ; SWAP } ;
                           { CDR ; CAR @init_slash_28 } ;
                           { CDR ; CAR %iHSec } ;
                           DIP { SOME } ;
                           UPDATE @swaps ;
                           PAIR @stor %swaps %nth ;
                           NIL operation ;
                           PAIR }
                         { UNIT @nth ;
                           { DIP { { DIP { DUP } ; SWAP } } ; SWAP } ;
                           CAR @stor_slash_30 ;
                           CAR %swaps ;
                           { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } ;
                           DUP ;
                           CAR %initTs ;
                           SWAP ;
                           CDR ;
                           DUP ;
                           CAR %refTime ;
                           SWAP ;
                           CDR ;
                           DUP ;
                           CAR %hSec ;
                           SWAP ;
                           CDR ;
                           DUP ;
                           CAR %sec ;
                           SWAP ;
                           CDR ;
                           DUP ;
                           CAR %initor ;
                           SWAP ;
                           CDR ;
                           DUP ;
                           CAR %partie ;
                           SWAP ;
                           CDR ;
                           CDR ;
                           AMOUNT ;
                           { DIP { { DIP { { DIP { { DIP { { DIP { { DIP { { DIP { { DIP { { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } ;
                           { CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CAR %value } ;
                           ADD ;
                           PAIR %value ;
                           SWAP ;
                           PAIR %partie ;
                           SWAP ;
                           PAIR %initor ;
                           SWAP ;
                           PAIR %sec ;
                           SWAP ;
                           PAIR %hSec ;
                           SWAP ;
                           PAIR %refTime ;
                           SWAP ;
                           PAIR @uSwap %initTs ;
                           SOME ;
                           { DIP { { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } } ; SWAP } ;
                           DIP { DIP { DIP { DIP { DROP } } } } ;
                           { CDR ; CDR ; CAR %hSec } ;
                           UPDATE @swaps ;
                           PAIR @stor %swaps %nth ;
                           NIL operation ;
                           PAIR } ; DIP { DROP } } ; PAIR } ;
                 PAIR @doInitiate ;
                 { DIP { DUP @init } ; SWAP } ;
                 DIP { DUP ; CAR ; SWAP ; CDR } ;
                 PAIR ;
                 EXEC ;
                 { DIP { { DIP { { DIP { { DIP { DUP @stor } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } ;
                 DIP { DUP ; CAR ; SWAP ; CDR } ;
                 DIP { DIP { DIP { DROP } } } ;
                 PAIR ;
                 EXEC }
               { IF_LEFT { RENAME @red_slash_66 ;
                           { DIP { DUP @transfer } ; SWAP } ;
                           LAMBDA @isRedeemable bytes (pair (lambda (pair bytes bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bytes)) bool) (pair bytes bytes))) bytes) { RENAME @hSec_slash_8 ; LAMBDA (pair bytes bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bytes)) bool) (pair bytes bytes)) { RENAME @closure_env_slash_9 ; DUP ; CAR @sec_slash_10 ; SWAP ; CDR @hSec_slash_8 ; PAIR ; LAMBDA (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bytes)) bool { RENAME @closure_env_slash_11 ; DUP ; CAR @swaps_slash_12 ; { DIP { DUP } ; SWAP } ; { CDR ; CAR @hSec_slash_8 } ; GET ; IF_NONE { PUSH bool False }
                                   { PUSH nat 32 ;
                                     { DIP { { DIP { DUP } ; SWAP } } ; SWAP } ;
                                     { CDR ; CDR @sec_slash_10 } ;
                                     SIZE ;
                                     COMPARE ;
                                     NEQ ;
                                     IF { PUSH string "secret size is not correct" ;
                                          FAILWITH }
                                        { { DIP { DUP } ; SWAP } ;
                                          { CDR ; CAR @hSec_slash_8 } ;
                                          { DIP { { DIP { DUP } ; SWAP } } ; SWAP } ;
                                          { CDR ; CDR @sec_slash_10 } ;
                                          SHA256 ;
                                          SHA256 ;
                                          COMPARE ;
                                          NEQ ;
                                          IF { PUSH string "secret is not correct" ;
                                               FAILWITH }
                                             { DUP @swap ;
                                               { CDR ; CAR %refTime } ;
                                               INT ;
                                               { DIP { DUP @swap } ; SWAP } ;
                                               CAR %initTs ;
                                               ADD ;
                                               NOW ;
                                               COMPARE ;
                                               GE ;
                                               IF { PUSH string "refundTime has come" ;
                                                    FAILWITH }
                                                  { DUP @swap ;
                                                    { CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CAR %empt } ;
                                                    IF { PUSH string "swap is emptied" ;
                                                         FAILWITH }
                                                       { PUSH bool True } } } } ;
                                     DIP { DROP } } ; DIP { DROP } } ; PAIR } ; PAIR } ;
                           PAIR ;
                           LAMBDA (pair (pair :redeem (bytes %rdHSec) (bytes %rdSec)) (pair (lambda bytes (pair (lambda (pair bytes bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bytes)) bool) (pair bytes bytes))) bytes)) (lambda address (pair (lambda (pair mutez address) (list operation)) address)))) (pair (lambda (pair (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit) (pair (lambda bytes (pair (lambda (pair bytes bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bytes)) bool) (pair bytes bytes))) bytes)) (pair (pair :redeem (bytes %rdHSec) (bytes %rdSec)) (lambda address (pair (lambda (pair mutez address) (list operation)) address))))) (pair (list operation) (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit))) (pair (lambda bytes (pair (lambda (pair bytes bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bytes)) bool) (pair bytes bytes))) bytes)) (pair (pair :redeem (bytes %rdHSec) (bytes %rdSec)) (lambda address (pair (lambda (pair mutez address) (list operation)) address))))) { RENAME @closure_env_slash_41 ; DUP ; { CDR ; CDR @transfer_slash_26 } ; { DIP { DUP } ; SWAP } ; CAR @red_slash_42 ; PAIR ; SWAP ; { CDR ; CAR @isRedeemable_slash_14 } ; PAIR ; LAMBDA (pair (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit) (pair (lambda bytes (pair (lambda (pair bytes bytes) (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) (pair bytes bytes)) bool) (pair bytes bytes))) bytes)) (pair (pair :redeem (bytes %rdHSec) (bytes %rdSec)) (lambda address (pair (lambda (pair mutez address) (list operation)) address))))) (pair (list operation) (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit)) { RENAME @closure_env_slash_43 ; DUP ; { CDR ; CAR @isRedeemable_slash_14 } ; { DIP { DUP } ; SWAP } ; { CDR ; CDR ; CAR @red_slash_42 } ; CAR %rdHSec ; EXEC ; { DIP { DUP } ; SWAP } ; { CDR ; CDR ; CAR @red_slash_42 } ; CDR %rdSec ; DIP { DUP ; CAR ; SWAP ; CDR } ; PAIR ; EXEC ; { DIP { DUP } ; SWAP } ; CAR @stor_slash_44 ; CAR %swaps ; DIP { DUP ; CAR ; SWAP ; CDR } ; PAIR ; EXEC ; NOT ; IF { PUSH string "hash is not found" ;
                                FAILWITH }
                              { UNIT } ; DROP ; DUP ; CAR @stor_slash_44 ; CAR %swaps ; { DIP { DUP } ; SWAP } ; { CDR ; CDR ; CAR @red_slash_42 } ; CAR %rdHSec ; GET ; IF_NONE { DUP ;
                                     CAR @stor_slash_44 ;
                                     NIL operation ;
                                     PAIR }
                                   { DUP @swap ;
                                     DUP ;
                                     CAR %initTs ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %refTime ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %hSec ;
                                     SWAP ;
                                     CDR ;
                                     CDR ;
                                     { DIP { { DIP { { DIP { { DIP { { DIP { DUP } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } ;
                                     { CDR ; CDR ; CAR @red_slash_42 } ;
                                     CDR %rdSec ;
                                     SOME ;
                                     PAIR %sec ;
                                     SWAP ;
                                     PAIR %hSec ;
                                     SWAP ;
                                     PAIR %refTime ;
                                     SWAP ;
                                     PAIR @swap %initTs ;
                                     DUP ;
                                     CAR %initTs ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %refTime ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %hSec ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %sec ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %initor ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %partie ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %value ;
                                     SWAP ;
                                     CDR ;
                                     CDR %state ;
                                     PUSH bool True ;
                                     PAIR %empt %state ;
                                     SWAP ;
                                     PAIR %value ;
                                     SWAP ;
                                     PAIR %partie ;
                                     SWAP ;
                                     PAIR %initor ;
                                     SWAP ;
                                     PAIR %sec ;
                                     SWAP ;
                                     PAIR %hSec ;
                                     SWAP ;
                                     PAIR %refTime ;
                                     SWAP ;
                                     PAIR @swap %initTs ;
                                     DUP ;
                                     CAR %initTs ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %refTime ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %hSec ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %sec ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %initor ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %partie ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %value ;
                                     SWAP ;
                                     CDR ;
                                     CAR %empt ;
                                     PUSH (or :state (unit %Empty) (unit %Initiator)) (Left Unit) ;
                                     SWAP ;
                                     PAIR %empt %state ;
                                     SWAP ;
                                     PAIR %value ;
                                     SWAP ;
                                     PAIR %partie ;
                                     SWAP ;
                                     PAIR %initor ;
                                     SWAP ;
                                     PAIR %sec ;
                                     SWAP ;
                                     PAIR %hSec ;
                                     SWAP ;
                                     PAIR %refTime ;
                                     SWAP ;
                                     PAIR @swap %initTs ;
                                     UNIT @nth ;
                                     { DIP { { DIP { { DIP { DUP } ; SWAP } } ; SWAP } } ; SWAP } ;
                                     CAR @stor_slash_44 ;
                                     CAR %swaps ;
                                     { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } ;
                                     { DIP { { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } } ; SWAP } ;
                                     { CDR ; CDR ; CAR %hSec } ;
                                     DIP { SOME } ;
                                     UPDATE @swaps ;
                                     PAIR @stor %swaps %nth ;
                                     { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } ;
                                     { CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CDR %state } ;
                                     IF_LEFT { DROP ;
                                               NIL operation }
                                             { DROP ;
                                               { DIP { { DIP { { DIP { DUP } ; SWAP } } ; SWAP } } ; SWAP } ;
                                               { CDR ; CDR ; CDR @transfer_slash_26 } ;
                                               { DIP { { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } } ; SWAP } ;
                                               { CDR ; CDR ; CDR ; CDR ; CDR ; CAR %partie } ;
                                               EXEC ;
                                               { DIP { { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } } ; SWAP } ;
                                               { CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CAR %value } ;
                                               DIP { DUP ; CAR ; SWAP ; CDR } ;
                                               PAIR ;
                                               EXEC } ;
                                     DIP { DIP { DROP ; DROP } } ;
                                     RENAME @u ;
                                     PAIR } ; DIP { DROP } } ; PAIR } ;
                           PAIR @doRedeem ;
                           { DIP { DUP @red } ; SWAP } ;
                           DIP { DUP ; CAR ; SWAP ; CDR } ;
                           PAIR ;
                           EXEC ;
                           { DIP { { DIP { { DIP { { DIP { DUP @stor } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } ;
                           DIP { DUP ; CAR ; SWAP ; CDR } ;
                           DIP { DIP { DIP { DROP } } } ;
                           PAIR ;
                           EXEC }
                         { RENAME @hSec_slash_67 ;
                           { DIP { DUP @transfer } ; SWAP } ;
                           LAMBDA @isRefundable bytes (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) bytes) bool) bytes) { RENAME @hSec_slash_3 ; LAMBDA (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) bytes) bool { RENAME @closure_env_slash_4 ; DUP ; CAR @swaps_slash_5 ; { DIP { DUP } ; SWAP } ; CDR @hSec_slash_3 ; GET ; IF_NONE { PUSH bool False }
                                   { DUP @swap ;
                                     { CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CAR %empt } ;
                                     IF { PUSH string "swap is emptied" ;
                                          FAILWITH }
                                        { DUP @swap ;
                                          { CDR ; CAR %refTime } ;
                                          INT ;
                                          { DIP { DUP @swap } ; SWAP } ;
                                          CAR %initTs ;
                                          ADD ;
                                          NOW ;
                                          COMPARE ;
                                          LT ;
                                          IF { PUSH string "refundTime has not come" ;
                                               FAILWITH }
                                             { PUSH bool True } } ;
                                     DIP { DROP } } ; DIP { DROP } } ; PAIR } ;
                           PAIR ;
                           LAMBDA (pair bytes (pair (lambda bytes (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) bytes) bool) bytes)) (lambda address (pair (lambda (pair mutez address) (list operation)) address)))) (pair (lambda (pair (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit) (pair bytes (pair (lambda bytes (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) bytes) bool) bytes)) (lambda address (pair (lambda (pair mutez address) (list operation)) address))))) (pair (list operation) (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit))) (pair bytes (pair (lambda bytes (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) bytes) bool) bytes)) (lambda address (pair (lambda (pair mutez address) (list operation)) address))))) { RENAME @closure_env_slash_54 ; DUP ; { CDR ; CDR @transfer_slash_26 } ; { DIP { DUP } ; SWAP } ; { CDR ; CAR @isRefundable_slash_7 } ; PAIR ; SWAP ; CAR @hSec_slash_55 ; PAIR ; LAMBDA (pair (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit) (pair bytes (pair (lambda bytes (pair (lambda (pair (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) bytes) bool) bytes)) (lambda address (pair (lambda (pair mutez address) (list operation)) address))))) (pair (list operation) (pair :storage (big_map bytes (pair :swap (timestamp %initTs) (pair (nat %refTime) (pair (bytes %hSec) (pair (option %sec bytes) (pair (address %initor) (pair (address %partie) (pair (mutez %value) (pair (bool %empt) (or :state %state (unit %Empty) (unit %Initiator))))))))))) unit)) { RENAME @closure_env_slash_56 ; DUP ; { CDR ; CDR ; CAR @isRefundable_slash_7 } ; { DIP { DUP } ; SWAP } ; { CDR ; CAR @hSec_slash_55 } ; EXEC ; { DIP { DUP } ; SWAP } ; CAR @stor_slash_57 ; CAR %swaps ; DIP { DUP ; CAR ; SWAP ; CDR } ; PAIR ; EXEC ; NOT ; IF { PUSH string "hash is not found" ;
                                FAILWITH }
                              { UNIT } ; DROP ; DUP ; CAR @stor_slash_57 ; CAR %swaps ; { DIP { DUP } ; SWAP } ; { CDR ; CAR @hSec_slash_55 } ; GET ; IF_NONE { DUP ;
                                     CAR @stor_slash_57 ;
                                     NIL operation ;
                                     PAIR }
                                   { DUP @swap ;
                                     DUP ;
                                     CAR %initTs ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %refTime ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %hSec ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %sec ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %initor ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %partie ;
                                     SWAP ;
                                     CDR ;
                                     DUP ;
                                     CAR %value ;
                                     SWAP ;
                                     CDR ;
                                     CDR %state ;
                                     PUSH bool True ;
                                     PAIR %empt %state ;
                                     SWAP ;
                                     PAIR %value ;
                                     SWAP ;
                                     PAIR %partie ;
                                     SWAP ;
                                     PAIR %initor ;
                                     SWAP ;
                                     PAIR %sec ;
                                     SWAP ;
                                     PAIR %hSec ;
                                     SWAP ;
                                     PAIR %refTime ;
                                     SWAP ;
                                     PAIR @swap %initTs ;
                                     UNIT @nth ;
                                     { DIP { { DIP { { DIP { DUP } ; SWAP } } ; SWAP } } ; SWAP } ;
                                     CAR @stor_slash_57 ;
                                     CAR %swaps ;
                                     { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } ;
                                     { DIP { { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } } ; SWAP } ;
                                     { CDR ; CDR ; CAR %hSec } ;
                                     DIP { SOME } ;
                                     UPDATE @swaps ;
                                     PAIR @stor %swaps %nth ;
                                     { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } ;
                                     { CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CDR %state } ;
                                     IF_LEFT { DROP ;
                                               NIL operation }
                                             { DROP ;
                                               { DIP { { DIP { { DIP { DUP } ; SWAP } } ; SWAP } } ; SWAP } ;
                                               { CDR ; CDR ; CDR @transfer_slash_26 } ;
                                               { DIP { { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } } ; SWAP } ;
                                               { CDR ; CDR ; CDR ; CDR ; CAR %initor } ;
                                               EXEC ;
                                               { DIP { { DIP { { DIP { DUP @swap } ; SWAP } } ; SWAP } } ; SWAP } ;
                                               { CDR ; CDR ; CDR ; CDR ; CDR ; CDR ; CAR %value } ;
                                               DIP { DUP ; CAR ; SWAP ; CDR } ;
                                               PAIR ;
                                               EXEC } ;
                                     DIP { DIP { DROP ; DROP } } ;
                                     RENAME @u ;
                                     PAIR } ; DIP { DROP } } ; PAIR } ;
                           PAIR @doRefund ;
                           { DIP { DUP @hSec } ; SWAP } ;
                           DIP { DUP ; CAR ; SWAP ; CDR } ;
                           PAIR ;
                           EXEC ;
                           { DIP { { DIP { { DIP { { DIP { DUP @stor } ; SWAP } } ; SWAP } } ; SWAP } } ; SWAP } ;
                           DIP { DUP ; CAR ; SWAP ; CDR } ;
                           DIP { DIP { DIP { DROP } } } ;
                           PAIR ;
                           EXEC } } ;
       DIP { DROP ; DROP ; DROP } }